version: "3.8"  # Specify the version of Docker Compose syntax being used
services:  # Define the services that make up your application
  backend-flask:  # Service definition for the backend Flask application
    environment:  # Set environment variables for the backend service
      FRONTEND_URL: "https://3000-${GITPOD_WORKSPACE_ID}.${GITPOD_WORKSPACE_CLUSTER_HOST}"  # URL for the frontend, dynamic based on Gitpod workspace
      BACKEND_URL: "https://4567-${GITPOD_WORKSPACE_ID}.${GITPOD_WORKSPACE_CLUSTER_HOST}"  # URL for the backend, dynamic based on Gitpod workspace
    build: ./backend-flask  # Build context for the backend service (path to Dockerfile or build context)
    ports:  # Expose ports for the backend service
      - "4567:4567"  # Map port 4567 on the host to port 4567 on the container
    volumes:  # Mount volumes for the backend service
      - ./backend-flask:/backend-flask  # Mount the current directory to /backend-flask in the container

  frontend-react-js:  # Service definition for the frontend React.js application
    environment:  # Set environment variables for the frontend service
      REACT_APP_BACKEND_URL: "https://4567-${GITPOD_WORKSPACE_ID}.${GITPOD_WORKSPACE_CLUSTER_HOST}"  # URL for the backend, dynamic based on Gitpod workspace
    build: ./frontend-react-js  # Build context for the frontend service (path to Dockerfile or build context)
    ports:  # Expose ports for the frontend service
      - "3000:3000"  # Map port 3000 on the host to port 3000 on the container
    volumes:  # Mount volumes for the frontend service
      - ./frontend-react-js:/frontend-react-js  # Mount the current directory to /frontend-react-js in the container

  db:  # Service definition for a PostgreSQL database
    image: postgres:13-alpine  # Use the official PostgreSQL image with Alpine Linux
    restart: always  # Always restart the container if it stops
    environment:  # Set environment variables for the PostgreSQL service
      - POSTGRES_USER=postgres  # Define the PostgreSQL user
      - POSTGRES_PASSWORD=password  # Define the PostgreSQL password
    ports:  # Expose ports for the database service
      - '5432:5432'  # Map port 5432 on the host to port 5432 on the container
    volumes:  # Mount volumes for the database service
      - db:/var/lib/postgresql/data  # Use a named volume for persistent storage

  dynamodb-local:  # Service definition for a local instance of DynamoDB
    user: root  # Run the container as root user
    command: "-jar DynamoDBLocal.jar -sharedDb -dbPath ./data"  # Command to run DynamoDB local
    image: "amazon/dynamodb-local:latest"  # Use the latest DynamoDB local image from Amazon
    container_name: dynamodb-local  # Name the container "dynamodb-local"
    ports:  # Expose ports for the DynamoDB local service
      - "8000:8000"  # Map port 8000 on the host to port 8000 on the container
    volumes:  # Mount volumes for the DynamoDB local service
      - "./docker/dynamodb:/home/dynamodblocal/data"  # Use a local directory for DynamoDB data
    working_dir: /home/dynamodblocal  # Set the working directory inside the container

volumes:  # Define named volumes for persistent storage
  db:  # Named volume for PostgreSQL data
    driver: local  # Use the local driver for the volume

networks:  # Define networks for the services
  internal-network:  # Internal network definition
    driver: bridge  # Use the bridge network driver (default for most use cases)
    name: cruddur  # Specify the name of the network
